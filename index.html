<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹 피아노</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Georgia 폰트 사용 */
        body {
            font-family: 'Georgia', serif; /* 폰트를 Georgia로 변경 */
            display: flex;
            flex-direction: column; /* 세로 정렬 */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5; /* 부드러운 배경색 */
            margin: 0;
            padding: 20px; /* 전체 패딩 추가 */
            box-sizing: border-box;
        }

        :root {
            /* 기본 건반 크기 및 간격 변수 */
            --white-key-width: 60px;
            --white-key-margin-right: 4px; /* 흰 건반 오른쪽 마진 */
            --black-key-width: 40px;
            --black-key-half-width: calc(var(--black-key-width) / 2);
            /* 흰 건반 하나가 차지하는 총 너비 (자체 너비 + 오른쪽 마진) */
            --white-key-total-segment-width: calc(var(--white-key-width) + var(--white-key-margin-right));
            /* 검은 건반의 상단 오프셋 */
            --black-key-top-offset: 0px; /* 기본값: 흰 건반 상단과 일치 */
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px; /* 전체 컨트롤 컨테이너 최대 너비 */
            align-items: center;
        }

        .app-title {
            font-size: 2.2em; /* 제목 크기 */
            font-weight: 700; /* 굵게 */
            color: #333; /* 어두운 글자색 */
            margin-bottom: 15px; /* 아래 여백 */
            text-align: center;
            width: 100%;
        }

        .input-group {
            display: flex;
            gap: 10px;
            width: 100%; /* 부모 컨테이너 너비에 맞춤 */
            max-width: 560px; /* input-group의 최대 너비 조정 */
            justify-content: center; /* 내부 요소 중앙 정렬 */
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 */
        }

        .input-group select,
        .input-group button {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1.1em;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            flex-grow: 0; /* Prevent growing beyond basis */
            flex-shrink: 0; /* Prevent shrinking below basis */
            min-width: unset;
            background-color: white; /* select 배경색 */
            cursor: pointer;
            box-sizing: border-box; /* padding and border included in width */
        }

        /* Specific flex-basis for chord controls (4 items) */
        .input-group.chord-controls select,
        .input-group.chord-controls button {
            flex-basis: 132.5px; /* (560px - 3*10px) / 4 */
        }

        /* Specific flex-basis for scale controls */
        .input-group.scale-controls #scaleSelect {
            flex-basis: 275px; /* 2 * 132.5px + 10px */
        }
        .input-group.scale-controls #highlightScaleButton,
        .input-group.scale-controls #resetScaleButton {
            flex-basis: 132.5px; /* Same as chord buttons */
        }

        .input-group button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap; /* 버튼 텍스트 줄바꿈 방지 */
        }
        .input-group button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }
        .input-group button:active {
            transform: translateY(1px);
        }

        /* Reset 버튼을 위한 새로운 스타일 */
        #resetButton, #resetScaleButton {
            background-color: #6c757d; /* 회색 */
        }
        #resetButton:hover, #resetScaleButton:hover {
            background-color: #5a6268; /* 더 어두운 회색 */
        }


        .code-examples {
            font-size: 0.9em;
            color: #666;
            text-align: center;
            width: 100%;
        }

        .sheet-music-container {
            margin-top: 20px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 600px; /* Align with controls-container */
            display: flex;
            justify-content: center;
        }
        #sheetMusicCanvas {
            background-color: #fefefe; /* White background for sheet music */
        }


        .piano-container {
            background-color: #333; /* 피아노 본체 색상 */
            padding: 20px;
            border-radius: 15px; /* 둥근 모서리 */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); /* 그림자 효과 */
            display: flex;
            position: relative; /* 컨테이너를 기준으로 절대 위치 지정 */
            flex-wrap: wrap;
            justify-content: center; /* 전체 피아노를 중앙 정렬 */
            max-width: 90%;
            margin-top: 20px;
        }

        .white-keys {
            display: flex;
            position: relative; /* 검은 건반의 absolute 기준 */
            width: fit-content; /* 내용물에 맞게 너비 조절 */
        }

        .key {
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            position: relative; /* for text positioning */
            transition: background-color 0.1s ease, transform 0.05s ease;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 10px;
            font-size: 0.8em;
            color: #555;
            user-select: none;
            box-sizing: border-box;
        }

        .key.active {
            transform: translateY(2px);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .key.highlight {
            background-color: #ffcc00 !important;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
        }
        .key.highlight.black-key {
            background-color: #8c7300 !important;
            color: #fff;
        }

        /* 푸른 점 스타일 */
        .key.selected-dot::after {
            content: '';
            position: absolute;
            bottom: 45px; /* 건반 아래쪽으로 45px 위 (음이름보다 위) */
            left: 50%;
            transform: translateX(-50%);
            width: 15px; /* 점의 너비 증가 */
            height: 15px; /* 점의 높이 증가 */
            background-color: #007bff; /* 푸른색 */
            border-radius: 50%; /* 원형 */
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.9); /* 그림자 효과 강화 */
        }
        .key.selected-dot.black-key::after {
            background-color: #a7d9ff; /* 검은 건반 위에서는 밝은 파란색 점 */
        }


        .white-key {
            width: var(--white-key-width);
            height: 200px;
            background-color: #fff;
            border-color: #999;
            margin-right: var(--white-key-margin-right);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }
        /* 마지막 흰 건반은 오른쪽 마진 없음 */
        .white-keys .white-key:last-child {
            margin-right: 0;
        }


        .black-key {
            width: var(--black-key-width);
            height: 120px;
            background-color: #000;
            border-color: #333;
            position: absolute; /* 개별 검은 건반의 절대 위치 */
            z-index: 1;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            color: #ccc;
        }

        .black-key.active {
            background-color: #333;
        }

        /* 검은 건반 그룹 (white-keys의 자식으로 변경) */
        .black-key-group {
            display: flex; /* 내부 검은 건반들을 flex로 배치 (실제로는 absolute가 우선) */
            position: absolute; /* white-keys를 기준으로 절대 위치 */
            top: var(--black-key-top-offset); /* CSS 변수를 사용하여 상단 위치 조정 */
            left: 0; /* white-keys의 왼쪽 끝에 정렬 */
            width: 100%; /* white-keys의 너비에 맞춤 */
        }

        /* 각 검은 건반의 정확한 위치 조정 (흰 건반 기준) */
        /* N은 검은 건반 왼쪽에 있는 흰 건반의 0-기반 인덱스 */
        /* left = N * (흰 건반 세그먼트 너비) + (흰 건반 너비 - 검은 건반 절반 너비) + (흰 건반 마진 / 2) */
        /* C# (N=0, C-D 사이) */ .key[data-note="C#"] { left: calc(0 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* D# (N=1, D-E 사이) */ .key[data-note="D#"] { left: calc(1 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* F# (N=3, F-G 사이) */ .key[data-note="F#"] { left: calc(3 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* G# (N=4, G-A 사이) */ .key[data-note="G#"] { left: calc(4 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* A# (N=5, A-B 사이) */ .key[data-note="A#"] { left: calc(5 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* C#2 (N=7) */ .key[data-note="C#2"] { left: calc(7 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* D#2 (N=8) */ .key[data-note="D#2"] { left: calc(8 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* F#2 (N=10) */ .key[data-note="F#2"] { left: calc(10 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* G#2 (N=11) */ .key[data-note="G#2"] { left: calc(11 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }
        /* A#2 (N=12) */ .key[data-note="A#2"] { left: calc(12 * var(--white-key-total-segment-width) + var(--white-key-width) - var(--black-key-half-width) + (var(--white-key-margin-right) / 2)); }


        /* 반응형 디자인 */
        @media (max-width: 768px) {
            :root {
                --white-key-width: 40px;
                --white-key-margin-right: 3px;
                --black-key-width: 25px;
                --black-key-half-width: calc(var(--black-key-width) / 2);
                --white-key-total-segment-width: calc(var(--white-key-width) + var(--white-key-margin-right));
                --black-key-top-offset: 0px; /* 중간 화면 크기 조정 */
            }
            .white-key {
                width: var(--white-key-width);
                height: 150px;
            }
            .black-key {
                width: var(--black-key-width);
                height: 90px;
            }
            .key {
                font-size: 0.7em;
            }
            .controls-container {
                padding: 15px;
            }
            /* On medium screens, allow elements to wrap to two per row if needed */
            .input-group select, .input-group button {
                flex-basis: calc(50% - 5px); /* 2 items per row, considering 10px gap */
            }
            /* Override specific flex-basis for larger screens */
            .input-group.chord-controls select,
            .input-group.chord-controls button,
            .input-group.scale-controls #scaleSelect,
            .input-group.scale-controls #highlightScaleButton,
            .input-group.scale-controls #resetScaleButton {
                flex-basis: calc(50% - 5px); /* Ensure they wrap to two per row */
            }
        }

        @media (max-width: 480px) {
            :root {
                --white-key-width: 30px;
                --white-key-margin-right: 2px;
                --black-key-width: 20px;
                --black-key-half-width: calc(var(--black-key-width) / 2);
                --white-key-total-segment-width: calc(var(--white-key-width) + var(--white-key-margin-right));
                --black-key-top-offset: 0px; /* 작은 화면 크기 조정 */
            }
            .white-key {
                width: var(--white-key-width);
                height: 120px;
            }
            .black-key {
                width: var(--black-key-width);
                height: 70px;
            }
            .key {
                font-size: 0.6em;
            }
            .controls-container {
                padding: 10px;
                gap: 10px;
            }
            .input-group {
                flex-direction: column;
            }
            .input-group select, .input-group button {
                width: 100%;
                min-width: unset;
                flex-basis: 100%; /* 전체 너비 차지 */
            }
        }
    </style>
</head>
<body>
    <div class="controls-container">
        <h1 class="app-title">HM's Music Study</h1>
        <div class="input-group chord-controls">
            <select id="rootNoteSelect">
                </select>
            <select id="chordTypeSelect">
                </select>
            <button id="highlightChordButton">Chord</button>
            <button id="resetButton">Reset</button>
        </div>
        <div class="input-group scale-controls">
            <label for="scaleSelect" class="sr-only">Scale Key</label>
            <select id="scaleSelect">
                </select>
            <button id="highlightScaleButton">Scale</button>
            <button id="resetScaleButton">Reset</button>
        </div>
        <div class="code-examples">
            코드의 근음과 화성 종류를 선택하고 'Chord' 버튼을 누르거나, 음계의 근음을 선택하고 'Scale' 버튼을 누르세요.
        </div>
    </div>

    <div class="sheet-music-container">
        <canvas id="sheetMusicCanvas" width="560" height="150" class="border border-gray-300 rounded-lg shadow-inner"></canvas>
    </div>

    <div class="piano-container">
        <div class="white-keys">
            <div class="key white-key" data-note="C" data-keyboard="A">C</div>
            <div class="key white-key" data-note="D" data-keyboard="S">D</div>
            <div class="key white-key" data-note="E" data-keyboard="D">E</div>
            <div class="key white-key" data-note="F" data-keyboard="F">F</div>
            <div class="key white-key" data-note="G" data-keyboard="G">G</div>
            <div class="key white-key" data-note="A" data-keyboard="H">A</div>
            <div class="key white-key" data-note="B" data-keyboard="J">B</div>

            <div class="key white-key" data-note="C2" data-keyboard="K">C</div>
            <div class="key white-key" data-note="D2" data-keyboard="L">D</div>
            <div class="key white-key" data-note="E2" data-keyboard=";">E</div>
            <div class="key white-key" data-note="F2" data-keyboard="'">F</div>
            <div class="key white-key" data-note="G2" data-keyboard="Z">G</div>
            <div class="key white-key" data-note="A2" data-keyboard="X">A</div>
            <div class="key white-key" data-note="B2" data-keyboard="C">B</div>

            <div class="black-keys black-key-group">
                <div class="key black-key" data-note="C#" data-keyboard="W">C#<br>Db</div>
                <div class="key black-key" data-note="D#" data-keyboard="E">D#<br>Eb</div>
                <div class="key black-key" data-note="F#" data-keyboard="T">F#<br>Gb</div>
                <div class="key black-key" data-note="G#" data-keyboard="Y">G#<br>Ab</div>
                <div class="key black-key" data-note="A#" data-keyboard="U">A#<br>Bb</div>
                <div class="key black-key" data-note="C#2" data-keyboard="O">C#<br>Db</div>
                <div class="key black-key" data-note="D#2" data-keyboard="P">D#<br>Eb</div>
                <div class="key black-key" data-note="F#2" data-keyboard="V">F#<br>Gb</div>
                <div class="key black-key" data-note="G#2" data-keyboard="B">G#<br>Ab</div>
                <div class="key black-key" data-note="A#2" data-keyboard="N">A#<br>Bb</div>
            </div>
        </div>
    </div>

    <script>
        // Keyboard key to note mapping (still used for note highlighting)
        const keyboardMap = {
            'A': 'C', 'S': 'D', 'D': 'E', 'F': 'F', 'G': 'G', 'H': 'A', 'J': 'B',
            'K': 'C2', 'L': 'D2', ';': 'E2', "'": 'F2',
            'W': 'C#', 'E': 'D#', 'T': 'F#', 'Y': 'G#', 'U': 'A#',
            'O': 'C#2', 'P': 'D#2', 'V': 'F#2', 'B': 'G#2', 'N': 'A#2'
        };

        // All notes in order (including sharps for calculation consistency)
        const allNotesInOrder = [
            'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B',
            'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2'
        ];

        // Map flat notes to their enharmonic sharp/natural equivalents for internal lookup
        const flatToSharpMap = {
            'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
            'Cb': 'B', 'Fb': 'E' // Less common, but good for completeness
        };

        // Chord definitions (based on intervals from root)
        const chords = {
            'major': [0, 4, 7],
            'minor': [0, 3, 7],
            '7': [0, 4, 7, 10],
            'maj7': [0, 4, 7, 11],
            'm7': [0, 3, 7, 10],
            'm7b5': [0, 3, 6, 10],
            'dim7': [0, 3, 6, 9]
        };

        // User-friendly chord type labels
        const chordTypeLabels = [
            { value: 'major', label: 'Major' },
            { value: 'minor', label: 'minor' },
            { value: 'm7', label: 'm7' },
            { value: '7', label: '7' },
            { value: 'maj7', label: 'M7' },
            { value: 'm7b5', label: 'm7b5' },
            { value: 'dim7', label: 'dim7' }
        ];

        // Major scale intervals
        const majorScaleIntervals = [0, 2, 4, 5, 7, 9, 11]; // Root, M2, M3, P4, P5, M6, M7

        // Major key labels with key signature counts (sorted as requested)
        const majorKeyLabels = [
            { value: 'C', label: 'C Major Key (0)' },
            { value: 'G', label: 'G Major Key (#1)' },
            { value: 'F', label: 'F Major Key (b1)' },
            { value: 'D', label: 'D Major Key (#2)' },
            { value: 'Bb', label: 'Bb Major Key (b2)' },
            { value: 'A', label: 'A Major Key (#3)' },
            { value: 'Eb', label: 'Eb Major Key (b3)' },
            { value: 'E', label: 'E Major Key (#4)' },
            { value: 'Ab', label: 'Ab Major Key (b4)' },
            { value: 'B', label: 'B Major Key (#5)' },
            { value: 'Db', label: 'Db Major Key (b5)' },
            { value: 'F#', label: 'F# Major Key (#6)' },
            { value: 'Gb', label: 'Gb Major Key (b6)' },
            { value: 'C#', label: 'C# Major Key (#7)' },
            { value: 'Cb', label: 'Cb Major Key (b7)' }
        ];

        // Key signature definitions: which notes are naturally sharped/flatted in each key
        const keySignatures = {
            'C': { sharps: [], flats: [] },
            'G': { sharps: ['F'], flats: [] },
            'D': { sharps: ['F', 'C'], flats: [] },
            'A': { sharps: ['F', 'C', 'G'], flats: [] },
            'E': { sharps: ['F', 'C', 'G', 'D'], flats: [] },
            'B': { sharps: ['F', 'C', 'G', 'D', 'A'], flats: [] },
            'F#': { sharps: ['F', 'C', 'G', 'D', 'A', 'E'], flats: [] },
            'C#': { sharps: ['F', 'C', 'G', 'D', 'A', 'E', 'B'], flats: [] },

            'F': { sharps: [], flats: ['B'] },
            'Bb': { sharps: [], flats: ['B', 'E'] },
            'Eb': { sharps: [], flats: ['B', 'E', 'A'] },
            'Ab': { sharps: [], flats: ['B', 'E', 'A', 'D'] },
            'Db': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G'] },
            'Gb': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G', 'C'] },
            'Cb': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G', 'C', 'F'] }
        };

        // Map semitone value (0-11) to its natural note name (C, D, E, F, G, A, B)
        const naturalNoteLetters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

        // Map semitone value (0-11) to its common sharp display name
        const semitoneToSharpDisplayNote = [
            'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
        ];
        // Map semitone value (0-11) to its common flat display name
        const semitoneToFlatDisplayNote = [
            'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'
        ];


        const pianoKeys = document.querySelectorAll('.key');

        // Mouse and Touch event listeners (toggle selected dot)
        pianoKeys.forEach(key => {
            key.addEventListener('mousedown', () => {
                key.classList.add('active'); // Instant press effect
                key.classList.toggle('selected-dot'); // Toggle dot on click
            });

            key.addEventListener('mouseup', () => {
                key.classList.remove('active'); // Remove press effect
            });

            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                key.classList.add('active'); // Instant press effect
                key.classList.toggle('selected-dot'); // Toggle dot on touch
            }, { passive: false });

            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                key.classList.remove('active'); // Remove press effect
            }, { passive: false });
        });

        // Keyboard event listeners (toggle selected dot)
        const pressedKeys = new Set(); // Track currently pressed keyboard keys

        document.addEventListener('keydown', (e) => {
            const keyboardKey = e.key.toUpperCase();
            // Process only if key is mapped and not already pressed (prevent repeat)
            if (keyboardMap[keyboardKey] && !pressedKeys.has(keyboardKey)) {
                const noteName = keyboardMap[keyboardKey];
                const keyElement = document.querySelector(`.key[data-note="${noteName}"]`);
                if (keyElement) {
                    keyElement.classList.add('active'); // Instant press effect
                    keyElement.classList.toggle('selected-dot'); // Toggle dot on key press
                    pressedKeys.add(keyboardKey); // Record key as pressed
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const keyboardKey = e.key.toUpperCase();
            // Process only if key was pressed and is now released
            if (keyboardMap[keyboardKey] && pressedKeys.has(keyboardKey)) {
                const noteName = keyboardMap[keyboardKey];
                const keyElement = document.querySelector(`.key[data-note="${noteName}"]`);
                if (keyElement) {
                    keyElement.classList.remove('active'); // Remove press effect
                    pressedKeys.delete(keyboardKey); // Record key as released
                }
            }
        });

        // --- Chord and Scale Highlight Functions ---
        const rootNoteSelect = document.getElementById('rootNoteSelect');
        const chordTypeSelect = document.getElementById('chordTypeSelect');
        const highlightChordButton = document.getElementById('highlightChordButton');
        const resetButton = document.getElementById('resetButton');
        const scaleSelect = document.getElementById('scaleSelect');
        const highlightScaleButton = document.getElementById('highlightScaleButton');
        const resetScaleButton = document.getElementById('resetScaleButton');

        // New canvas and context for sheet music display
        const sheetMusicCanvas = document.getElementById('sheetMusicCanvas');
        const sheetMusicCtx = sheetMusicCanvas.getContext('2d');

        // Sheet music drawing parameters
        const staffLineHeight = 15; // Distance between staff lines
        const staffTopMargin = 30; // Margin from canvas top to first staff line (F5 line)
        const noteRadius = 7;
        // Adjusted for wider spacing and center alignment
        const scaleNoteSpacing = 60; // Horizontal spacing between notes in a scale (increased)
        const scaleNoteStartX = (sheetMusicCanvas.width - (majorScaleIntervals.length - 1) * scaleNoteSpacing) / 2; // Starting X position for notes in a scale (calculated for centering)

        // New constants for horizontal chord display
        const chordDisplaySpacing = 30; // Horizontal spacing between notes in a chord (reduced from 40)


        // Function to populate dropdowns
        function populateDropdowns() {
            // Populate Root Note dropdown
            const rootNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const enharmonicNotes = {
                'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
            };

            rootNotes.forEach(note => {
                const option = document.createElement('option');
                option.value = note;
                option.textContent = note;
                if (enharmonicNotes[note]) {
                    option.textContent += `/${enharmonicNotes[note]}`;
                }
                rootNoteSelect.appendChild(option);
            });

            // Populate Chord Type dropdown
            chordTypeLabels.forEach(chord => {
                const option = document.createElement('option');
                option.value = chord.value;
                option.textContent = chord.label;
                chordTypeSelect.appendChild(option);
            });

            // Populate Scale Key dropdown
            majorKeyLabels.forEach(key => {
                const option = document.createElement('option');
                option.value = key.value;
                option.textContent = key.label; // Use the updated label with key signature count
                scaleSelect.appendChild(option);
            });
        }

        /**
         * Function to draw the 5 staff lines on the canvas.
         */
        function drawStaff() {
            sheetMusicCtx.clearRect(0, 0, sheetMusicCanvas.width, sheetMusicCanvas.height); // Clear canvas
            sheetMusicCtx.strokeStyle = '#333';
            sheetMusicCtx.lineWidth = 1;

            for (let i = 0; i < 5; i++) {
                const y = staffTopMargin + i * staffLineHeight;
                sheetMusicCtx.beginPath();
                sheetMusicCtx.moveTo(0, y);
                sheetMusicCtx.lineTo(sheetMusicCanvas.width, y);
                sheetMusicCtx.stroke();
            }

            // Draw a simple treble clef symbol
            sheetMusicCtx.font = '80px Arial'; // Increased font size for clef
            sheetMusicCtx.fillStyle = '#333';
            sheetMusicCtx.textAlign = 'left';
            sheetMusicCtx.textBaseline = 'top';
            // Adjusted y position to move it down by one staff space (staffLineHeight / 2)
            sheetMusicCtx.fillText(' ', 10, staffTopMargin - 25 + (staffLineHeight / 2));
        }

        /**
         * Calculates the Y position on the staff for a given note name,
         * and determines if an accidental or ledger lines are needed.
         * @param {string} noteName - The note name (e.g., 'C', 'C#', 'Db', 'C2').
         * @returns {object|null} - An object with y, accidental, and ledgerLines array, or null if not found.
         */
        function getNoteYPositionAndLedgerInfo(noteName) {
            let baseNote = noteName.replace('2', ''); // e.g., 'C', 'C#', 'Db'
            let octave = noteName.includes('2') ? 1 : 0; // 0 for C-B, 1 for C2-B2

            let naturalNoteLetterForPosition; // The natural note letter (C, D, E, F, G, A, B) for staff position
            let accidentalForDisplay = ''; // The accidental symbol to display (# or b)

            if (baseNote.length === 1) { // Natural notes like C, D, E, F, G, A, B
                naturalNoteLetterForPosition = baseNote;
                accidentalForDisplay = '';
            } else { // Sharp or Flat notes (e.g., C#, Db)
                const letter = baseNote.charAt(0);
                const modifier = baseNote.charAt(1);

                if (modifier === '#') {
                    naturalNoteLetterForPosition = letter;
                    accidentalForDisplay = '#';
                } else if (modifier === 'b') {
                    // For flat notes, the natural note letter for staff position is the letter itself.
                    // e.g., Bb is on the B line/space, Eb is on the E line/space.
                    // Special cases: Cb is B, Fb is E.
                    if (letter === 'C' && modifier === 'b') { // Cb
                        naturalNoteLetterForPosition = 'B';
                    } else if (letter === 'F' && modifier === 'b') { // Fb
                        naturalNoteLetterForPosition = 'E';
                    } else {
                        naturalNoteLetterForPosition = letter; // This is the fix: use the letter itself
                    }
                    accidentalForDisplay = 'b';
                } else {
                    console.warn(`Invalid note format: ${noteName}`);
                    return null;
                }
            }

            const naturalNoteIndexInOctave = naturalNoteLetters.indexOf(naturalNoteLetterForPosition);
            if (naturalNoteIndexInOctave === -1) {
                console.warn(`Could not determine natural note index for: ${noteName}`);
                return null;
            }

            // Calculate total natural note index across octaves (C4=0, D4=1, ..., B4=6, C5=7, ...)
            // F5 (top staff line) is the reference, which is totalNaturalNoteIndex = 10 (F is 3rd natural note, C5-B5 octave is 7 steps higher: 3+7=10)
            const yStep = staffLineHeight / 2; // Distance between a line and a space
            const F5_Y = staffTopMargin; // Y position of the top staff line (F5)
            const y = F5_Y + (10 - (naturalNoteIndexInOctave + (octave * 7))) * yStep; // Higher notes have lower Y values

            // Determine ledger lines
            let ledgerLines = [];
            const bottomStaffLineY = staffTopMargin + 4 * staffLineHeight;
            const topStaffLineY = staffTopMargin;

            if (y > bottomStaffLineY + yStep) {
                let currentLedgerY = bottomStaffLineY + yStep * 2;
                while (y >= currentLedgerY - yStep) {
                    ledgerLines.push(currentLedgerY);
                    currentLedgerY += staffLineHeight;
                }
            } else if (y < topStaffLineY - yStep) {
                let currentLedgerY = topStaffLineY - yStep * 2;
                while (y <= currentLedgerY + yStep) {
                    ledgerLines.push(currentLedgerY);
                    currentLedgerY -= staffLineHeight;
                }
            }

            // Determine stem direction
            const middleLineY = staffTopMargin + 2 * staffLineHeight;
            const stemDirection = (y < middleLineY) ? 'down' : 'up';

            return { y, accidental: accidentalForDisplay, ledgerLines, stemDirection };
        }

        /**
         * Draws a note head on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} x - X coordinate for the note head.
         * @param {number} y - Y coordinate for the note head.
         */
        function drawNoteHead(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, noteRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        /**
         * Draws an accidental (# or b) next to a note head.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} x - X coordinate for the note head.
         * @param {number} y - Y coordinate for the note head.
         * @param {string} accidental - The accidental symbol ('#' or 'b').
         */
        function drawAccidental(ctx, x, y, accidental) {
            ctx.font = '20px Arial'; // Font for accidental symbol
            ctx.fillStyle = 'black';
            ctx.textAlign = 'right'; // Align text to the left of the note head
            ctx.textBaseline = 'middle';
            ctx.fillText(accidental, x - noteRadius - 5, y); // Position to the left of the note
        }

        /**
         * Draws a ledger line.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} y - Y coordinate for the ledger line.
         * @param {number} xPos - X position of the note for which the ledger line is drawn.
         */
        function drawLedgerLine(ctx, y, xPos) {
            const ledgerLineLength = noteRadius * 3; // Length of the ledger line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(xPos - ledgerLineLength / 2, y);
            ctx.lineTo(xPos + ledgerLineLength / 2, y);
            ctx.stroke();
        }

        /**
         * Generates the notes of a major scale with correct enharmonic spellings based on the key signature.
         * @param {string} rootNote - The root of the scale (e.g., 'C', 'F').
         * @param {string} currentKey - The selected major key (e.g., 'F', 'G').
         * @returns {string[]} An array of note names (e.g., ['F', 'G', 'A', 'Bb', 'C', 'D', 'E']).
         */
        function getScaleNotesForDisplay(rootNote, currentKey) {
            const scaleNotes = [];
            // Convert rootNote to its canonical sharp/natural form for initial index lookup
            let canonicalRootNoteForLookup = flatToSharpMap[rootNote] || rootNote;
            let rootIndexInAllNotes = allNotesInOrder.indexOf(canonicalRootNoteForLookup);

            if (rootIndexInAllNotes === -1) {
                console.warn(`Invalid root note for scale: ${rootNote}`);
                return [];
            }

            const keyInfo = keySignatures[currentKey];
            if (!keyInfo) {
                console.warn(`Invalid key signature: ${currentKey}`);
                return [];
            }

            const isFlatKey = keyInfo.flats.length > 0;

            majorScaleIntervals.forEach(interval => {
                let absoluteSemitoneIndex = rootIndexInAllNotes + interval; // Absolute index in the 2-octave range

                let semitoneValueInOctave = absoluteSemitoneIndex % 12; // 0-11 for C-B
                let octaveSuffix = '';
                if (absoluteSemitoneIndex >= 12) { // If it's in the second octave of the piano
                    octaveSuffix = '2';
                }

                let displayNoteNameBase;
                if (isFlatKey) {
                    displayNoteNameBase = semitoneToFlatDisplayNote[semitoneValueInOctave];
                } else {
                    displayNoteNameBase = semitoneToSharpDisplayNote[semitoneValueInOctave];
                }

                scaleNotes.push(displayNoteNameBase + octaveSuffix);
            });
            return scaleNotes;
        }

        /**
         * Helper to calculate text positions centered around a given X.
         * @param {number} centerX - The center X coordinate for the block of text.
         * @param {number} numNotes - The number of notes (text labels).
         * @param {number} spacing - The horizontal spacing between text labels.
         * @returns {number[]} An array of X positions for each text label.
         */
        function calculateTextPositionsCenteredAround(centerX, numNotes, spacing) {
            const totalTextWidth = (numNotes - 1) * spacing;
            const startX = centerX - (totalTextWidth / 2);
            const positions = [];
            for (let i = 0; i < numNotes; i++) {
                positions.push(startX + (i * spacing));
            }
            return positions;
        }

        /**
         * Draws notes on the sheet music canvas.
         * @param {string[][]} noteSets - An array of note arrays. Each inner array is a set of notes for one chord/scale.
         * @param {'chord'|'scale'} type - The type of display ('chord' for stacked, 'scale' for sequential).
         * @param {boolean} isDualDisplay - True if drawing two chords side-by-side (enharmonic roots).
         */
        function drawSheetMusic(noteSets, type, isDualDisplay = false) {
            drawStaff(); // Clear canvas and draw staff lines and clef

            // Fixed Y for note names (below the staff)
            const textYBelowStaff = staffTopMargin + 5 * staffLineHeight + 15;

            noteSets.forEach((notes, setIndex) => {
                // Sort notes to ensure consistent vertical stacking/horizontal ordering
                notes.sort((a, b) => {
                    const getSemitoneValueForSort = (note) => {
                        let base = note.replace('2', '');
                        let semitoneVal;
                        if (base.includes('#')) {
                            semitoneVal = semitoneToSharpDisplayNote.indexOf(base);
                        } else if (base.includes('b')) {
                            semitoneVal = semitoneToFlatDisplayNote.indexOf(base);
                        } else { // Natural note
                            semitoneVal = semitoneToSharpDisplayNote.indexOf(base);
                        }

                        if (note.includes('2')) { // Add 12 for the second octave
                            semitoneVal += 12;
                        }
                        return semitoneVal;
                    };
                    return getSemitoneValueForSort(a) - getSemitoneValueForSort(b);
                });

                let notesDisplayStartX; // X position for the first note in a set (for horizontal display)
                let textLabelsXPositions = []; // X positions for the text labels of this note set

                if (type === 'chord') {
                    // For chords, notes are stacked vertically, but text labels are horizontally spread
                    if (isDualDisplay) {
                        const spacingBetweenChordStacks = 180; // Increased space between the two stacked note heads
                        const centerOfCanvas = sheetMusicCanvas.width / 2;

                        if (setIndex === 0) { // First chord (sharp/primary)
                            notesDisplayStartX = centerOfCanvas - (spacingBetweenChordStacks / 2);
                        } else { // Second chord (flat/enharmonic)
                            notesDisplayStartX = centerOfCanvas + (spacingBetweenChordStacks / 2);
                        }

                        // Calculate text labels X positions centered around their respective chord stack X
                        textLabelsXPositions = calculateTextPositionsCenteredAround(
                            notesDisplayStartX, // Center text labels around the stacked chord notes
                            notes.length,
                            chordDisplaySpacing
                        );

                    } else { // Single chord display
                        notesDisplayStartX = sheetMusicCanvas.width / 2; // Chord notes are stacked vertically in the center
                        textLabelsXPositions = calculateTextPositionsCenteredAround(
                            notesDisplayStartX,
                            notes.length,
                            chordDisplaySpacing
                        );
                    }
                } else if (type === 'scale') {
                    // For scales, both notes and text labels are horizontally spread
                    notesDisplayStartX = scaleNoteStartX;
                    textLabelsXPositions = []; // Not used directly, as currentNoteX is already sequential
                }


                notes.forEach((note, noteIndex) => {
                    const noteInfo = getNoteYPositionAndLedgerInfo(note);
                    if (noteInfo) {
                        const { y, accidental, ledgerLines, stemDirection } = noteInfo;
                        let currentNoteX;

                        if (type === 'chord') {
                            currentNoteX = notesDisplayStartX; // All notes in a chord are at the same X for stacking
                            // No stems for chords
                        } else if (type === 'scale') {
                            currentNoteX = scaleNoteStartX + (noteIndex * scaleNoteSpacing);
                            // Existing stem drawing logic for scales
                            const stemLength = staffLineHeight * 3.5; // Standard stem length
                            let stemStartX, stemStartY, stemEndX, stemEndY;

                            if (stemDirection === 'up') {
                                stemStartX = currentNoteX + noteRadius;
                                stemStartY = y;
                                stemEndX = currentNoteX + noteRadius;
                                stemEndY = y - stemLength;
                            } else { // 'down'
                                stemStartX = currentNoteX - noteRadius;
                                stemStartY = y;
                                stemEndX = currentNoteX - noteRadius;
                                stemEndY = y + stemLength;
                            }

                            sheetMusicCtx.beginPath();
                            sheetMusicCtx.moveTo(stemStartX, stemStartY);
                            sheetMusicCtx.lineTo(stemEndX, stemEndY);
                            sheetMusicCtx.stroke();
                        }

                        drawNoteHead(sheetMusicCtx, currentNoteX, y);

                        if (accidental) {
                            drawAccidental(sheetMusicCtx, currentNoteX, y, accidental);
                        }

                        ledgerLines.forEach(lineY => {
                            drawLedgerLine(sheetMusicCtx, lineY, currentNoteX);
                        });

                        // Draw note name
                        sheetMusicCtx.font = '12px Arial'; // Font size for note name
                        sheetMusicCtx.fillStyle = 'black';
                        sheetMusicCtx.textAlign = 'center'; // Center text

                        let noteTextX;
                        let noteTextY = textYBelowStaff; // Always use fixed Y for text below staff
                        sheetMusicCtx.textBaseline = 'top'; // Align text to the top of its bounding box (draws downwards)


                        if (type === 'chord') {
                            // For chords, text labels are horizontally spread below the staff
                            noteTextX = textLabelsXPositions[noteIndex];
                        } else { // 'scale'
                            // For scales, text labels are below the staff and horizontally aligned
                            noteTextX = currentNoteX;
                        }
                        sheetMusicCtx.fillText(note.replace('2', ''), noteTextX, noteTextY); // Display note name without octave number
                    }
                });
            });
        }


        /**
         * Generates chord notes with appropriate enharmonic spelling based on root and chord type.
         * @param {number} rootIndex - The semitone index of the root note (0-11).
         * @param {string} chordType - The type of chord (e.g., 'minor', 'major').
         * @param {string|null} primaryAccidentalPreference - 'sharp', 'flat', or null for natural roots.
         * @returns {string[]} An array of note names with correct enharmonic spelling.
         */
        function generateChordNotesForDisplay(rootIndex, chordType, primaryAccidentalPreference) {
            const notesForDisplay = [];
            const intervals = chords[chordType];

            intervals.forEach(interval => {
                let targetSemitone = (rootIndex + interval) % 12;
                let octaveSuffix = '';
                if (rootIndex + interval >= 12) { // Check if it crosses into the next octave
                    octaveSuffix = '2';
                }

                let noteNameForDisplay = '';

                if (primaryAccidentalPreference === 'sharp') {
                    noteNameForDisplay = semitoneToSharpDisplayNote[targetSemitone];
                } else if (primaryAccidentalPreference === 'flat') {
                    noteNameForDisplay = semitoneToFlatDisplayNote[targetSemitone];
                } else { // Natural root, apply standard minor/diminished spelling rules
                    if (chordType === 'minor' || chordType === 'm7' || chordType === 'm7b5' || chordType === 'dim7') {
                        // For minor 3rd, minor 7th, diminished 5th, prefer flat spelling if it's a black key
                        if (interval === 3 || interval === 10 || (interval === 6 && (chordType === 'm7b5' || chordType === 'dim7'))) {
                            if (semitoneToFlatDisplayNote[targetSemitone].includes('b')) {
                                noteNameForDisplay = semitoneToFlatDisplayNote[targetSemitone];
                            } else {
                                noteNameForDisplay = semitoneToSharpDisplayNote[targetSemitone];
                            }
                        } else { // Root and perfect 5th remain natural/sharp
                            noteNameForDisplay = semitoneToSharpDisplayNote[targetSemitone];
                        }
                    } else { // Major, Dominant 7th, Major 7th chords on natural root
                        noteNameForDisplay = semitoneToSharpDisplayNote[targetSemitone];
                    }
                }
                notesForDisplay.push(noteNameForDisplay + octaveSuffix);
            });
            return notesForDisplay;
        }


        /**
         * Highlights the selected chord on the piano and draws it on the sheet music.
         */
        function highlightChord() {
            // Remove existing highlights from piano keys
            pianoKeys.forEach(key => key.classList.remove('highlight'));

            const rootNote = rootNoteSelect.value; // e.g., 'C', 'C#', 'Db'
            const chordType = chordTypeSelect.value;

            if (!rootNote || !chordType) {
                console.warn("근음과 화성 종류를 모두 선택해주세요.");
                drawStaff(); // Clear sheet music if no selection
                return;
            }

            // Convert rootNote to its canonical sharp/natural form for internal interval calculation
            let canonicalRootNoteForIntervalCalc = flatToSharpMap[rootNote] || rootNote;
            const rootIndex = allNotesInOrder.indexOf(canonicalRootNoteForIntervalCalc);

            if (rootIndex === -1) {
                console.warn(`알 수 없는 근음입니다: ${rootNote}`);
                drawStaff(); // Clear sheet music if invalid root
                return;
            }

            const intervals = chords[chordType];
            if (!intervals) {
                console.warn(`지원하지 않는 코드 타입입니다: ${chordType}.`);
                drawStaff(); // Clear sheet music if invalid chord type
                return;
            }

            // 1. Determine notes for PIANO HIGHLIGHTING (always sharp/natural for data-note lookup)
            const notesForPianoHighlight = [];
            intervals.forEach(interval => {
                let targetIndex = rootIndex + interval;
                while (targetIndex >= allNotesInOrder.length) {
                    targetIndex -= 12; // Adjust for octave
                }
                notesForPianoHighlight.push(allNotesInOrder[targetIndex]);
            });

            // Determine the primary accidental preference for the *selected root note's chord display*
            let primaryAccidentalPreference = null; // 'sharp' or 'flat'
            if (rootNote.includes('#')) {
                primaryAccidentalPreference = 'sharp';
            } else if (rootNote.includes('b')) {
                primaryAccidentalPreference = 'flat';
            }
            const notesForSheetMusicDisplayPrimary = generateChordNotesForDisplay(rootIndex, chordType, primaryAccidentalPreference);


            // --- Dual Display Logic for Black Key Roots ---
            let enharmonicRootNameForDisplay = null;
            const rootSemitone = allNotesInOrder.indexOf(rootNote.replace('2', '')) % 12;

            // Check if the selected root is a black key that has both sharp and flat names
            if (semitoneToSharpDisplayNote[rootSemitone].includes('#') && semitoneToFlatDisplayNote[rootSemitone].includes('b')) {
                if (rootNote.includes('#')) {
                    enharmonicRootNameForDisplay = semitoneToFlatDisplayNote[rootSemitone]; // C# -> Db
                } else if (rootNote.includes('b')) {
                    enharmonicRootNameForDisplay = semitoneToSharpDisplayNote[rootSemitone]; // Db -> C#
                }
            }

            if (enharmonicRootNameForDisplay) {
                // Calculate the enharmonic root's index for interval calculation
                let canonicalEnharmonicRootForIntervalCalc = flatToSharpMap[enharmonicRootNameForDisplay] || enharmonicRootNameForDisplay;
                const enharmonicRootIndex = allNotesInOrder.indexOf(canonicalEnharmonicRootForIntervalCalc);

                // Determine the accidental preference for the enharmonic version
                let enharmonicAccidentalPreference = null;
                if (enharmonicRootNameForDisplay.includes('#')) {
                    enharmonicAccidentalPreference = 'sharp';
                } else if (enharmonicRootNameForDisplay.includes('b')) {
                    enharmonicAccidentalPreference = 'flat';
                }

                const notesForSheetMusicDisplayEnharmonic = generateChordNotesForDisplay(enharmonicRootIndex, chordType, enharmonicAccidentalPreference);
                drawSheetMusic([notesForSheetMusicDisplayPrimary, notesForSheetMusicDisplayEnharmonic], 'chord', true);
            } else {
                drawSheetMusic([notesForSheetMusicDisplayPrimary], 'chord', false);
            }

            // Highlight on piano keys
            notesForPianoHighlight.forEach(noteToFind => {
                const keyElement = document.querySelector(`.key[data-note="${noteToFind}"]`);
                if (keyElement) {
                    keyElement.classList.add('highlight');
                }
            });
        }

        /**
         * Highlights the selected scale on the piano and draws it on the sheet music.
         */
        function highlightScale() {
            // Remove existing highlights from piano keys
            pianoKeys.forEach(key => key.classList.remove('highlight'));

            const selectedKey = scaleSelect.value;

            if (!selectedKey) {
                console.warn("음계의 근음을 선택해주세요.");
                drawStaff(); // Clear sheet music if no selection
                return;
            }

            // Generate scale notes with correct enharmonic spelling for display
            const notesForSheetMusic = getScaleNotesForDisplay(selectedKey, selectedKey);

            // For piano key highlighting, convert back to the sharp/natural format used by data-note attributes
            const notesForPianoHighlight = notesForSheetMusic.map(note => {
                let baseNote = note.replace('2', '');
                let octaveSuffix = note.includes('2') ? '2' : '';
                // Use flatToSharpMap to convert flat notes to their sharp equivalents for piano key lookup
                if (flatToSharpMap[baseNote]) {
                    return flatToSharpMap[baseNote] + octaveSuffix;
                }
                return note; // If it's already sharp/natural or C, F, G, etc.
            });

            // Highlight on piano keys
            notesForPianoHighlight.forEach(noteToFind => {
                const keyElement = document.querySelector(`.key[data-note="${noteToFind}"]`);
                if (keyElement) {
                    keyElement.classList.add('highlight');
                }
            });

            // Draw on sheet music canvas as a scale
            drawSheetMusic([notesForSheetMusic], 'scale', false); // Pass the correctly spelled notes
        }


        /**
         * Clears all highlights and selected dots from piano keys and the sheet music canvas.
         */
        function resetHighlights() {
            pianoKeys.forEach(key => {
                key.classList.remove('highlight');
                key.classList.remove('selected-dot');
                key.classList.remove('active'); // Ensure active state is also cleared
            });
            // Also reset the pressedKeys set for keyboard inputs
            pressedKeys.clear();
            drawStaff(); // Clear the sheet music canvas
        }


        // On page load, populate dropdowns and draw an empty staff
        window.onload = function() {
            populateDropdowns();
            drawStaff(); // Draw initial empty staff
        };

        // Button click events
        highlightChordButton.addEventListener('click', highlightChord);
        resetButton.addEventListener('click', resetHighlights);
        highlightScaleButton.addEventListener('click', highlightScale);
        resetScaleButton.addEventListener('click', resetHighlights);
    </script>
</body>
</html>
 